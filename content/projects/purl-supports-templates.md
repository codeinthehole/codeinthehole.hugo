---
{
  "aliases": ["/writing/purl-uri-templates-and-generated-tests"],
  "description": "Matching the RFC using Nose's test generators",
  "title": "purl, URI templates and generated tests",
  "tags": ["python", "testing"],
  "slug": "purl-uri-templates-and-generated-tests",
  "date": "2013-07-09",
}
---

_TLDR_: Parameterised tests are a useful testing technique. Both Nose and
py.test support them.

### URI templates in purl

The newly released [purl 0.8](https://github.com/codeinthehole/purl) (a URL
library of mine) supports URI templates as per
[RFC 6570](http://tools.ietf.org/html/rfc6570). These allow new URL instances to
be created by passing bindings to a template instance.

```python
>>> import purl
>>> tpl = purl.Template('http://www.google.com{path}')
>>> tpl.expand({'path': ['a', 'b', 'c']}).as_string()
'http://www.google.com/a/b/c'
```

Alternatively, you can expand template strings directly:

```python
>>> purl.expand('{?list*}', {'list': ['a', 'b', 'c']})
'/a/b/c'
```

There's a plethora of ways template URLs can be used - see the
[RFC](http://tools.ietf.org/html/rfc6570) for details.

<div class="admonition warning">
    Note, there's
    <a href="https://github.com/uri-templates/uritemplate-py">already a Python library that provides this functionality</a>. I
    decided not to use that one with purl as I thought I could do better.
    Plus, it looked like fun and I wanted to learn more about Python's
    support for parameterised tests.

</div>

### Parameterised tests

I'd like to draw your attention to parameterised, or generated, tests which were
used to drive development of this feature.

#### Example

The RFC includes a range of example templates, bindings and expected outputs:

![image](/images/screenshots/rfc6570.png)

These are excellent material for driving a series of parametric tests since each
example comprises the inputs and expected output for a test. The natural way to
test such examples is using parameterised tests.

#### PHPUnit

PHP's dominant testing library,
[PHPUnit](http://phpunit.de/manual/current/en/index.html), support
[data providers](http://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.data-providers)
that can used to solve this problem (in a slightly clunky way).

There's a Python port of this functionality in
[django-oscar's testing utilities](https://github.com/tangentlabs/django-oscar/blob/master/oscar/test/decorators.py#L4-L27)
(and many other places no doubt) however there's better way to write
parameterised tests in Python.

#### Nose

I used
[Nose's test generators](http://nose.readthedocs.org/en/latest/writing_tests.html#test-generators)
to drive TDD on purl.

These allow tests to be generated by `yield`ing a tuple `(test_fn, *test_args)`
for each dataset. Here, `test_fn` is a callable that takes arguments `test_args`
and should raise an `AssertionError` if the test fails.

Consider the above snippet from section 3.2.2 of the RFC: tests for this section
can be constructed as:

```python
import purl
from nose.tools import eq_

level1_vars = {
    'var': 'value',
    'hello': 'Hello World!',
}

# Tuples of (template, bindings, expected URI)
test_data = [
    ('{var}', level1_vars, 'value'),
    ('{hello}', level1_vars, 'Hello%20World%21'),
]

def assert_expansion(template, fields, expected):
    eq_(purl.expand(template, fields), expected)

def test_expansion():
    for template, fields, expected in test_data:
        yield assert_expansion, template, fields, expected
```

which executes each example as a single test:

```bash
$ nosetests tests/expansion_tests.py
tests.expansion_tests.test_expansion('{var}', {'var': 'value', 'hello': 'Hello World!'}, 'value') ... ok
tests.expansion_tests.test_expansion('{hello}', {'var': 'value', 'hello': 'Hello World!'}, 'Hello%20World%21') ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
```

<div class="admonition note">
    I have verbose output turned on by default since my <code>~/nose.cfg</code> file
    contains the line <code>verbosity=2</code>.
</div>

Here we construct a simple assertion function using the `eq_` equality check
from Nose's test tools.

The default verbose output is a little too verbose for my tastes. It can be
cleaned up by providing a `description` attribute on the yielded callable:

```python
def test_expansion():
    for template, fields, expected in test_data:
        assert_expansion.description = "%s expands to %s" % (template, expected)
        yield assert_expansion, template, fields, expected
```

which looks like:

```bash
$ nosetests tests/expansion_tests.py
{var} expands to value ... ok
{hello} expands to Hello%20World%21 ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
```

Much nicer.

<div class="admonition warning">
    Updating the description suffers from a known bug where
    <a href="https://code.google.com/p/python-nose/issues/detail?id=244">failure reports always use the last description assigned to callable</a>.
    There are a few work-arounds detailed in the bug comments but none play
    nicely with Nose's multiprocess plugin.
</div>

#### py.test

In researching this post, I discovered [py.test](http://pytest.org/latest/)
supports a
[rich array of functionality](http://pytest.org/latest/example/parametrize.html)
for creating parameterised or generated tests.

Using py.test's `@pytest.mark.parameterize`
[decorator](http://pytest.org/latest/parametrize.html#pytest-mark-parametrize),
we can rewrite the above example as:

```python
import pytest

@pytest.mark.parametrize(("template", "fields", "expected"), data)
def test_expand(template, fields, expected):
    assert expand(template, fields) ==  expected
```

with verbose output:

```bash
$ py.test -v tests/pytest_tests.py
platform darwin -- Python 2.7.2 -- pytest-2.3.5 -- /Users/dwinterbottom/.virtualenvs/purl/bin/python
collected 2 items

tests/pytest_tests.py:123: test_expand[{var}-fields0-value] PASSED
tests/pytest_tests.py:123: test_expand[{hello}-fields1-Hello%20World%21] PASSED
```

I have a feeling I will be switching to py.test shortly.

### Summary

Test generators are a useful addition to your testing toolkit.

There's a couple of things to be aware of when using Nose's generated tests:

- It's not possible to run just one of the examples from the commandline.
- It's tempting to create the assertion function inline within the `test_*`
  function. However this doesn't work if you run your tests across multiple
  processes using Nose's `--processes` option.

Here's a few examples of using this functionality:

- The
  [expanded version of the above example from the Purl library](https://github.com/codeinthehole/purl/blob/master/tests/expansion_tests.py)
- [A set of tests from django-oscar](https://github.com/tangentlabs/django-oscar/blob/master/tests/unit/payment/bankcard_tests.py#L26-52)
  for testing validation of the Luhn algorithm.

Related articles:

- [Introduction to Functional Web Testing with Twill and Selenium](http://swordstyle.com/func_test_tutorial/part_one/extra_generative_tests.html) -
  Using test generators to drive functional tests.
- [Nosetests, Generators and Descriptions](http://achinghead.com/nosetests-generators-descriptions.html) -
  A detailed description of the bug with using a custom description for Nose's
  generated tests.
